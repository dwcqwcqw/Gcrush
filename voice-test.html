<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³åŠŸèƒ½æµ‹è¯•é¡µé¢ - Voice Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #ffffff;
        }
        
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .test-section h2 {
            color: #A259FF;
            margin-top: 0;
        }
        
        button {
            background: #A259FF;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #8a47e8;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .recording {
            background: #ff4444 !important;
        }
        
        .log-area {
            background: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin: 10px 0;
        }
        
        input, textarea {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #666;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin: 5px 0;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
        }
        
        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196F3;
        }
        
        audio {
            width: 100%;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>ğŸ¤ è¯­éŸ³åŠŸèƒ½å…¨é¢æµ‹è¯•é¡µé¢</h1>
    
    <!-- ç¯å¢ƒæ£€æŸ¥ -->
    <div class="test-section">
        <h2>1. ç¯å¢ƒæ£€æŸ¥</h2>
        <button onclick="checkEnvironment()">æ£€æŸ¥æµè§ˆå™¨ç¯å¢ƒ</button>
        <div id="envStatus"></div>
    </div>
    
    <!-- APIç«¯ç‚¹æµ‹è¯• -->
    <div class="test-section">
        <h2>2. APIç«¯ç‚¹è¿é€šæ€§æµ‹è¯•</h2>
        <button onclick="testSpeechToTextEndpoint()">æµ‹è¯•è¯­éŸ³è½¬æ–‡å­—ç«¯ç‚¹</button>
        <button onclick="testTextToSpeechEndpoint()">æµ‹è¯•æ–‡å­—è½¬è¯­éŸ³ç«¯ç‚¹</button>
        <div id="apiStatus"></div>
    </div>
    
    <!-- è¯­éŸ³å½•åˆ¶æµ‹è¯• -->
    <div class="test-section">
        <h2>3. è¯­éŸ³å½•åˆ¶æµ‹è¯•</h2>
        <button id="recordBtn" onclick="toggleRecording()">å¼€å§‹å½•åˆ¶</button>
        <button onclick="playRecording()" disabled id="playBtn">æ’­æ”¾å½•åˆ¶</button>
        <button onclick="analyzeAudio()" disabled id="analyzeBtn">åˆ†æéŸ³é¢‘è´¨é‡</button>
        <div id="recordStatus"></div>
        <audio id="recordedAudio" controls style="display: none;"></audio>
    </div>
    
    <!-- è¯­éŸ³è½¬æ–‡å­—æµ‹è¯• -->
    <div class="test-section">
        <h2>4. è¯­éŸ³è½¬æ–‡å­—å®Œæ•´æµ‹è¯•</h2>
        <p>ç”¨æˆ·IDï¼ˆæµ‹è¯•ç”¨ï¼‰ï¼š</p>
        <input type="text" id="testUserId" value="test-user-123" placeholder="è¾“å…¥æµ‹è¯•ç”¨æˆ·ID">
        <button onclick="testSpeechToText()" id="sttBtn">ä¸Šä¼ éŸ³é¢‘å¹¶è½¬æ¢ä¸ºæ–‡å­—</button>
        <div id="sttStatus"></div>
        <div id="sttResult"></div>
    </div>
    
    <!-- æ–‡å­—è½¬è¯­éŸ³æµ‹è¯• -->
    <div class="test-section">
        <h2>5. æ–‡å­—è½¬è¯­éŸ³å®Œæ•´æµ‹è¯•</h2>
        <p>æµ‹è¯•æ–‡æœ¬ï¼š</p>
        <textarea id="testText" rows="3" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡å­—">ä½ å¥½ï¼Œè¿™æ˜¯ä¸€ä¸ªè¯­éŸ³æµ‹è¯•ã€‚Hello, this is a voice test.</textarea>
        <p>è§’è‰²IDï¼ˆæµ‹è¯•ç”¨ï¼‰ï¼š</p>
        <input type="text" id="testCharacterId" value="test-character-456" placeholder="è¾“å…¥æµ‹è¯•è§’è‰²ID">
        <p>ç”¨æˆ·IDï¼ˆæµ‹è¯•ç”¨ï¼‰ï¼š</p>
        <input type="text" id="testUserIdTts" value="test-user-123" placeholder="è¾“å…¥æµ‹è¯•ç”¨æˆ·ID">
        <button onclick="testTextToSpeech()" id="ttsBtn">è½¬æ¢ä¸ºè¯­éŸ³</button>
        <div id="ttsStatus"></div>
        <audio id="ttsResult" controls style="display: none;"></audio>
    </div>
    
    <!-- è¯¦ç»†æ—¥å¿— -->
    <div class="test-section">
        <h2>6. è¯¦ç»†æ—¥å¿—</h2>
        <button onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
        <div id="logArea" class="log-area"></div>
    </div>

    <script>
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordedBlob = null;
        
        function log(message) {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            logArea.textContent += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
            console.log(message);
        }
        
        function showStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
            log(`${type.toUpperCase()}: ${message}`);
        }
        
        function clearLogs() {
            document.getElementById('logArea').textContent = '';
        }
        
        // 1. ç¯å¢ƒæ£€æŸ¥
        function checkEnvironment() {
            log('å¼€å§‹ç¯å¢ƒæ£€æŸ¥...');
            
            const checks = [];
            
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                checks.push('âœ… æµè§ˆå™¨æ”¯æŒ getUserMedia');
            } else {
                checks.push('âŒ æµè§ˆå™¨ä¸æ”¯æŒ getUserMedia');
            }
            
            if (window.MediaRecorder) {
                checks.push('âœ… æµè§ˆå™¨æ”¯æŒ MediaRecorder');
            } else {
                checks.push('âŒ æµè§ˆå™¨ä¸æ”¯æŒ MediaRecorder');
            }
            
            if (window.FormData) {
                checks.push('âœ… æµè§ˆå™¨æ”¯æŒ FormData');
            } else {
                checks.push('âŒ æµè§ˆå™¨ä¸æ”¯æŒ FormData');
            }
            
            if (window.fetch) {
                checks.push('âœ… æµè§ˆå™¨æ”¯æŒ fetch API');
            } else {
                checks.push('âŒ æµè§ˆå™¨ä¸æ”¯æŒ fetch API');
            }
            
            // æ£€æŸ¥ HTTPS
            if (location.protocol === 'https:' || location.hostname === 'localhost') {
                checks.push('âœ… è¿è¡Œåœ¨å®‰å…¨ç¯å¢ƒ (HTTPS/localhost)');
            } else {
                checks.push('âŒ æœªè¿è¡Œåœ¨å®‰å…¨ç¯å¢ƒï¼ŒgetUserMedia å¯èƒ½è¢«é˜»æ­¢');
            }
            
            showStatus('envStatus', checks.join('<br>'), 'info');
        }
        
        // 2. APIç«¯ç‚¹æµ‹è¯•
        async function testSpeechToTextEndpoint() {
            log('æµ‹è¯•è¯­éŸ³è½¬æ–‡å­—ç«¯ç‚¹è¿é€šæ€§...');
            try {
                const response = await fetch('/api/speech-to-text', {
                    method: 'OPTIONS'
                });
                
                if (response.ok) {
                    showStatus('apiStatus', 'âœ… è¯­éŸ³è½¬æ–‡å­—ç«¯ç‚¹è¿é€šæ­£å¸¸', 'success');
                } else {
                    showStatus('apiStatus', `âŒ è¯­éŸ³è½¬æ–‡å­—ç«¯ç‚¹å¼‚å¸¸: ${response.status}`, 'error');
                }
            } catch (error) {
                showStatus('apiStatus', `âŒ è¯­éŸ³è½¬æ–‡å­—ç«¯ç‚¹è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        async function testTextToSpeechEndpoint() {
            log('æµ‹è¯•æ–‡å­—è½¬è¯­éŸ³ç«¯ç‚¹è¿é€šæ€§...');
            try {
                const response = await fetch('/api/text-to-speech', {
                    method: 'OPTIONS'
                });
                
                if (response.ok) {
                    showStatus('apiStatus', 'âœ… æ–‡å­—è½¬è¯­éŸ³ç«¯ç‚¹è¿é€šæ­£å¸¸', 'success');
                } else {
                    showStatus('apiStatus', `âŒ æ–‡å­—è½¬è¯­éŸ³ç«¯ç‚¹å¼‚å¸¸: ${response.status}`, 'error');
                }
            } catch (error) {
                showStatus('apiStatus', `âŒ æ–‡å­—è½¬è¯­éŸ³ç«¯ç‚¹è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // 3. è¯­éŸ³å½•åˆ¶æµ‹è¯•
        async function toggleRecording() {
            const recordBtn = document.getElementById('recordBtn');
            
            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                await startRecording();
            } else {
                stopRecording();
            }
        }
        
        async function startRecording() {
            log('å¼€å§‹å½•åˆ¶éŸ³é¢‘...');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm'
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                        log(`å½•åˆ¶æ•°æ®å—: ${event.data.size} bytes`);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    recordedBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    log(`å½•åˆ¶å®Œæˆï¼Œæ€»å¤§å°: ${recordedBlob.size} bytes`);
                    
                    const audioUrl = URL.createObjectURL(recordedBlob);
                    const audioElement = document.getElementById('recordedAudio');
                    audioElement.src = audioUrl;
                    audioElement.style.display = 'block';
                    
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('analyzeBtn').disabled = false;
                    showStatus('recordStatus', `âœ… å½•åˆ¶å®Œæˆï¼ŒéŸ³é¢‘å¤§å°: ${recordedBlob.size} bytes`, 'success');
                };
                
                mediaRecorder.start(1000); // æ¯ç§’ç”Ÿæˆä¸€ä¸ªæ•°æ®å—
                
                document.getElementById('recordBtn').textContent = 'åœæ­¢å½•åˆ¶';
                document.getElementById('recordBtn').classList.add('recording');
                showStatus('recordStatus', 'ğŸ¤ æ­£åœ¨å½•åˆ¶...', 'info');
                
            } catch (error) {
                log(`å½•åˆ¶å¤±è´¥: ${error.message}`);
                showStatus('recordStatus', `âŒ å½•åˆ¶å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                document.getElementById('recordBtn').textContent = 'å¼€å§‹å½•åˆ¶';
                document.getElementById('recordBtn').classList.remove('recording');
                log('å½•åˆ¶å·²åœæ­¢');
            }
        }
        
        function playRecording() {
            const audioElement = document.getElementById('recordedAudio');
            audioElement.play();
            log('æ’­æ”¾å½•åˆ¶çš„éŸ³é¢‘');
            
            // Check audio duration and provide feedback
            audioElement.addEventListener('loadedmetadata', function() {
                log(`éŸ³é¢‘æ—¶é•¿: ${audioElement.duration.toFixed(2)} ç§’`);
                if (audioElement.duration < 0.5) {
                    showStatus('recordStatus', 'âš ï¸ éŸ³é¢‘æ—¶é•¿å¤ªçŸ­ï¼Œå¯èƒ½å½•åˆ¶å¤±è´¥', 'error');
                }
            });
        }
        
        function analyzeAudio() {
            if (!recordedBlob) {
                showStatus('recordStatus', 'âŒ è¯·å…ˆå½•åˆ¶éŸ³é¢‘', 'error');
                return;
            }
            
            log('åˆ†æéŸ³é¢‘æ–‡ä»¶...');
            
            // Create audio context to analyze the audio
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const fileReader = new FileReader();
            
            fileReader.onload = function(e) {
                audioContext.decodeAudioData(e.target.result).then(function(buffer) {
                    const duration = buffer.duration;
                    const numberOfChannels = buffer.numberOfChannels;
                    const sampleRate = buffer.sampleRate;
                    const length = buffer.length;
                    
                    log(`éŸ³é¢‘åˆ†æç»“æœ:`);
                    log(`- æ—¶é•¿: ${duration.toFixed(2)} ç§’`);
                    log(`- å£°é“æ•°: ${numberOfChannels}`);
                    log(`- é‡‡æ ·ç‡: ${sampleRate} Hz`);
                    log(`- æ ·æœ¬æ•°: ${length}`);
                    
                    // Check for silence (very low amplitude)
                    const channelData = buffer.getChannelData(0);
                    let maxAmplitude = 0;
                    for (let i = 0; i < channelData.length; i++) {
                        maxAmplitude = Math.max(maxAmplitude, Math.abs(channelData[i]));
                    }
                    
                    log(`- æœ€å¤§éŸ³é‡: ${(maxAmplitude * 100).toFixed(2)}%`);
                    
                    if (maxAmplitude < 0.01) {
                        showStatus('recordStatus', 'âŒ æ£€æµ‹åˆ°é™éŸ³ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™å’ŒéŸ³é‡', 'error');
                    } else if (maxAmplitude < 0.1) {
                        showStatus('recordStatus', 'âš ï¸ éŸ³é‡è¾ƒä½ï¼Œå»ºè®®é è¿‘éº¦å…‹é£è¯´è¯', 'info');
                    } else {
                        showStatus('recordStatus', 'âœ… éŸ³é¢‘è´¨é‡è‰¯å¥½', 'success');
                    }
                    
                }).catch(function(error) {
                    log(`éŸ³é¢‘è§£ç å¤±è´¥: ${error.message}`);
                    showStatus('recordStatus', `âŒ éŸ³é¢‘è§£ç å¤±è´¥: ${error.message}`, 'error');
                });
            };
            
            fileReader.readAsArrayBuffer(recordedBlob);
        }
        
        // 4. è¯­éŸ³è½¬æ–‡å­—æµ‹è¯•
        async function testSpeechToText() {
            if (!recordedBlob) {
                showStatus('sttStatus', 'âŒ è¯·å…ˆå½•åˆ¶éŸ³é¢‘', 'error');
                return;
            }
            
            const userId = document.getElementById('testUserId').value;
            if (!userId) {
                showStatus('sttStatus', 'âŒ è¯·è¾“å…¥ç”¨æˆ·ID', 'error');
                return;
            }
            
            log('å¼€å§‹è¯­éŸ³è½¬æ–‡å­—æµ‹è¯•...');
            document.getElementById('sttBtn').disabled = true;
            
            try {
                const formData = new FormData();
                formData.append('audio', recordedBlob, 'recording.webm');
                formData.append('userId', userId);
                
                log(`ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶å¤§å°: ${recordedBlob.size} bytes`);
                log(`ç”¨æˆ·ID: ${userId}`);
                
                const response = await fetch('/api/speech-to-text', {
                    method: 'POST',
                    body: formData
                });
                
                log(`APIå“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);
                
                const result = await response.text();
                log(`APIåŸå§‹å“åº”: ${result}`);
                
                let jsonResult;
                try {
                    jsonResult = JSON.parse(result);
                } catch (parseError) {
                    log(`JSONè§£æé”™è¯¯: ${parseError.message}`);
                    showStatus('sttStatus', `âŒ å“åº”æ ¼å¼é”™è¯¯: ${result}`, 'error');
                    return;
                }
                
                if (response.ok && jsonResult.success) {
                    showStatus('sttStatus', 'âœ… è¯­éŸ³è½¬æ–‡å­—æˆåŠŸ', 'success');
                    document.getElementById('sttResult').innerHTML = `
                        <div class="status success">
                            <strong>è½¬æ¢ç»“æœ:</strong> ${jsonResult.text}<br>
                            <strong>éŸ³é¢‘å­˜å‚¨:</strong> ${jsonResult.audioUrl}
                        </div>
                    `;
                } else {
                    showStatus('sttStatus', `âŒ è¯­éŸ³è½¬æ–‡å­—å¤±è´¥: ${jsonResult.error}`, 'error');
                    if (jsonResult.details) {
                        log(`é”™è¯¯è¯¦æƒ…: ${jsonResult.details}`);
                    }
                    if (jsonResult.stack) {
                        log(`é”™è¯¯å †æ ˆ: ${jsonResult.stack}`);
                    }
                }
                
            } catch (error) {
                log(`è¯­éŸ³è½¬æ–‡å­—è¯·æ±‚å¤±è´¥: ${error.message}`);
                showStatus('sttStatus', `âŒ è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
            } finally {
                document.getElementById('sttBtn').disabled = false;
            }
        }
        
        // 5. æ–‡å­—è½¬è¯­éŸ³æµ‹è¯•
        async function testTextToSpeech() {
            const text = document.getElementById('testText').value;
            const characterId = document.getElementById('testCharacterId').value;
            const userId = document.getElementById('testUserIdTts').value;
            
            if (!text || !characterId || !userId) {
                showStatus('ttsStatus', 'âŒ è¯·å¡«å†™æ‰€æœ‰å¿…éœ€å­—æ®µ', 'error');
                return;
            }
            
            log('å¼€å§‹æ–‡å­—è½¬è¯­éŸ³æµ‹è¯•...');
            document.getElementById('ttsBtn').disabled = true;
            
            try {
                const requestData = {
                    text: text,
                    characterId: characterId,
                    userId: userId
                };
                
                log(`è¯·æ±‚æ•°æ®: ${JSON.stringify(requestData, null, 2)}`);
                
                const response = await fetch('/api/text-to-speech', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                log(`APIå“åº”çŠ¶æ€: ${response.status} ${response.statusText}`);
                
                const result = await response.text();
                log(`APIåŸå§‹å“åº”: ${result}`);
                
                let jsonResult;
                try {
                    jsonResult = JSON.parse(result);
                } catch (parseError) {
                    log(`JSONè§£æé”™è¯¯: ${parseError.message}`);
                    showStatus('ttsStatus', `âŒ å“åº”æ ¼å¼é”™è¯¯: ${result}`, 'error');
                    return;
                }
                
                if (response.ok && jsonResult.success) {
                    showStatus('ttsStatus', 'âœ… æ–‡å­—è½¬è¯­éŸ³æˆåŠŸ', 'success');
                    
                    const audioElement = document.getElementById('ttsResult');
                    audioElement.src = jsonResult.audioUrl;
                    audioElement.style.display = 'block';
                    
                    log(`ç”Ÿæˆçš„éŸ³é¢‘URL: ${jsonResult.audioUrl}`);
                } else {
                    showStatus('ttsStatus', `âŒ æ–‡å­—è½¬è¯­éŸ³å¤±è´¥: ${jsonResult.error}`, 'error');
                    if (jsonResult.details) {
                        log(`é”™è¯¯è¯¦æƒ…: ${jsonResult.details}`);
                    }
                    if (jsonResult.stack) {
                        log(`é”™è¯¯å †æ ˆ: ${jsonResult.stack}`);
                    }
                }
                
            } catch (error) {
                log(`æ–‡å­—è½¬è¯­éŸ³è¯·æ±‚å¤±è´¥: ${error.message}`);
                showStatus('ttsStatus', `âŒ è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
            } finally {
                document.getElementById('ttsBtn').disabled = false;
            }
        }
        
        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æŸ¥ç¯å¢ƒ
        window.onload = function() {
            log('è¯­éŸ³åŠŸèƒ½æµ‹è¯•é¡µé¢å·²åŠ è½½');
            checkEnvironment();
        };
    </script>
</body>
</html>